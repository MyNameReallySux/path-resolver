<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"PathResolver.js.html":{"id":"PathResolver.js.html","title":"Source: PathResolver.js","body":" Documentation Classes PathResolver Source: PathResolver.js 'use strict' import fs from 'fs' import path from 'path' import { print, info, debug, warn, error, supressConsole, restoreConsole } from './lib/ConsoleUtils' import { toCamelCase, toSnakeCase } from '@beautiful-code/string-utils' import { isFunction, isObject, isString } from '@beautiful-code/type-utils' import { DuplicateKeyError, InvalidArgumentsError } from './errors' /* * TODO(Chris): Export these functions to external modules. */ const Externals = { hasDuplicateKeys: (object, other) =&gt; { let result = false Object.keys(object).map((key) =&gt; { if(other.hasOwnProperty(key)){ result = true return false } }) return result }, isFileURI: (uri) =&gt; { return uri.split('/').pop().indexOf('.') &gt; -1 }, isDirectoryURI: (uri) =&gt; { return path.split('/').pop().indexOf('.') == -1 }, filterObject: (object) =&gt; { const result = {} Object.keys(object) .filter((key) =&gt; object[key] !== undefined) .forEach((key) =&gt; result[key] = object[key]) return result }, hasKeyAvailable: (obj, key, onSuccess, onError) =&gt; { let contains = obj.hasOwnProperty(key) try { if(contains){ throw new DuplicateKeyError(`The given object has duplicate keys '${key}'. Make sure all directories have unique key, or use scopes / aliases'`) } else { isFunction(onSuccess) ? onSuccess(false) : undefined return false } } catch (e){ isFunction(onError) ? onError(true, e) : error(e) return true } return contains } } let { filterObject, hasDuplicateKeys, hasKeyAvailable, isDirectoryURI, isFileURI } = Externals /** * Class that creates a suite of methods useful for resolving paths within a project. Includes a directory resolver, * which creates relative path resolvers for each directory in a given directory map. Support for resolver renaming and * alias generation, which formats the resolver name to reflect the alias as the root rather than the full path. */ class PathResolver { static defaultOptions = { depth: -1, fileroot: 'files', namespace: 'paths', paths: {}, resolverPrefix: 'resolve', rootPath: fs.realpathSync(process.cwd()), } // Class Initialization /** * Creates an instance of PathResolver. Passes arguments to {@link PathResolver#initialize} to be processed. * * @param {!String|!Object} rootPath|paths Projects root path or Object mapping projects directory structure * @param {?Object} paths|options Object mapping projects directory structure or options object * @param {?Object} options Options object * * @see {@link PathResolver#initialize} */ constructor(...args){ this.initialize(...args) } /** * Configures an instance of path resolver. Can be used after a {@link PathResolver} instance is * created to defer the configuration. Passes arguments to the {@link PathResolver#initialize} function to be * processed and validated and sets the options instance property. Then passes on the configured * rootPath, paths object, and designated fileroot * * @param {!String|!Object} rootPath|paths Projects root path or Object mapping projects directory structure * @param {?Object} paths|options Object mapping projects directory structure or options object * @param {?Object} options Options object * * @function * @public */ initialize = (...args) =&gt; { this.options = this._handleArgs(...args) let { namespace } = this.options let { directoryResolver, aliasResolver } = this._getInitialResolvers(namespace) this._createResolver(directoryResolver, aliasResolver, this.options) } /** * Creates a resolver function, relative to the given path. * * @param {!String} rootPath The absolute path which the resolver will be relative to. * @returns {Function} Returns a function that returns a path relative to rootPath * * @example * let resolver = makeRelativeResolver('absolute/path') * let path = resolver('index.html') * * console.log(path) // absolute/path/index.html * @function * @public */ makeRelativeResolver = (rootPath) =&gt; (relativePath = '') =&gt; path.resolve(rootPath, relativePath) // Private Methods /** * Creates a resolver function, relative to the given path. * * @example * let resolver = makeRelativeResolver('absolute/path') * let path = resolver('index.html') * * console.log(path) // absolute/path/index.html * * @param {!String} rootPath The absolute path which the resolver will be relative to. * @function * @private */ _addPathToResolver = (resolverKey, resolverPath, resolver) =&gt; { hasKeyAvailable(resolver, resolverKey, () =&gt; { resolver[resolverKey] = this.makeRelativeResolver(resolverPath) }) } _addAliasToResolver = (key, path, resolver) =&gt; { return hasKeyAvailable(resolver, key, () =&gt; { return resolver[key] = path }) } _createResolver = (directoryResolver, aliasResolver, { depth, fileroot, paths, rootPath }) =&gt; { const _resolveLevel = ({ localPaths, parentPath, scope, index = 0, ignoreDuplicates = false}) =&gt; { const _handleStringValue = (value) =&gt; { return this._formatFullPath(value, parentPath, rootPath) } const _handleObjectValue = (key, value) =&gt; { let localRootPath = this._getNextParentPath(key, parentPath) let nextScope = this._getNextScope(key, scope) let resolverKey = this._getDirectoryResolverKey(key, scope) if(this._hasAlias(value)){ _handleObjectAlias(key, value, localRootPath) } if(this._hasLocalAlias(value)){ let localAlias = value._ nextScope = this._getNextScope(localAlias, scope) resolverKey = this._getDirectoryResolverKey(localAlias, scope) } let isValidDepth = depth == -1 || index &lt;= depth let duplicatesAreNotPresent = !directoryResolver.hasOwnProperty(resolverKey) if(isValidDepth &amp;&amp; duplicatesAreNotPresent){ this._addPathToResolver(resolverKey, localRootPath, directoryResolver) } return _resolveLevel({ localPaths: value, parentPath: localRootPath, scope: nextScope, index: ++index, ignoreDuplicates: true }) } const _handleObjectAlias = (key, value, localRootPath) =&gt; { let aliasKey = value._.replace('@', '') let aliasScope = this._getLocalScope(value, scope) let aliasResolverKey = this._getDirectoryResolverKey(aliasScope) let aliasPath = this._formatFullPath(key, parentPath, rootPath) if(!aliasResolver.hasOwnProperty(key)){ this._addPathToResolver(aliasResolverKey, aliasPath, directoryResolver) this._addAliasToResolver(aliasKey, aliasPath, aliasResolver) } _resolveLevel({ localPaths: value, parentPath: localRootPath, scope: aliasScope, index: 0 }) } const localResolver = Object.entries(localPaths).reduce((resolver, [key, value]) =&gt; { if(isString(value) &amp;&amp; isFileURI(value) &amp;&amp; key != '_'){ resolver[key] = _handleStringValue(value) } else if(isObject(value)){ resolver[key] = _handleObjectValue(key, value) } return resolver }, {}) return localResolver } let fullResolver = _resolveLevel({localPaths: paths}) this._setFileMap(fileroot, rootPath, fullResolver) } _formatFullPath = (filename, parentPath, rootPath) =&gt; parentPath &amp;&amp; rootPath ? path.resolve(rootPath, parentPath, filename) : parentPath || rootPath ? path.resolve(parentPath || rootPath , filename) : filename _formatResolverKey = (key) =&gt; toCamelCase(`${this.options.resolverPrefix}-${toSnakeCase(key)}`) /** * Creates a directory resolver key, or a dynamic function name, to be applied to the directory resolver. * * @param {?String} key Key for current directory or file * @param {?String} scope A string representation of the nested path in kebab case 'this-is-kebab-case' * * @returns {String} Name for dynamically generated resolver function. * * @private * @function * @memberof PathResolver# */ _getDirectoryResolverKey = (key, scope) =&gt; { let result if(scope &amp;&amp; key){ let keyToResolve = `${scope}-${key}` result = this._formatResolverKey(keyToResolve) } else if(key){ result = this._formatResolverKey(key) } return result } _getInitialResolvers = (namespace) =&gt; { let directoryResolver, aliasResolver if(namespace){ this[namespace] = {} this[namespace]['aliases'] = {} directoryResolver = this[namespace] } else { directoryResolver = this } aliasResolver = directoryResolver['aliases'] = {} return { directoryResolver, aliasResolver } } /** * Gets the current scope. Checks if current item has an alias scope, otherwise returns scope. * * @param {!String} key Key for current directory or file * @param {!String} scope A string representation of the nested path in kebab case 'this-is-kebab-case' * @throws {TypeError} _getLocalScope was passed no valid parameters, would have returned undefined * @returns {String} Name for dynamically generated resolver function. * * @function * @private * @memberof PathResolver# */ _getLocalScope = (localPaths, scope) =&gt; { if(localPaths &amp;&amp; this._hasAlias(localPaths) || this._hasLocalAlias(localPaths)){ let localScope = localPaths._.replace('@', '') return localScope } else if(scope) { return scope } else { throw new TypeError(`_getLocalScope was passed no valid parameters, would have returned undefined`) } } _getNextParentPath = (key, parentPath) =&gt; parentPath ? `${parentPath}/${key}` : key _getNextScope = (key, scope) =&gt; scope ? `${scope}-${key}` : key _handleArgs = (...args) =&gt; { let options switch(args.length){ case 0: { warn(`A 'PathResolver' object was passed no initial arguments. Initialization must be done manually by running the 'initialize' function.`) options = {} } break case 1: { if(isObject(args[0])){ options = { paths: args[0] } } } break case 2: { if(isObject(args[0]) &amp;&amp; isObject(args[1])){ if(args[1].hasOwnProperty('paths')){ warn(`PathResolver was passed a 'paths' argument and an options object with the 'paths' property. Will use 'paths' argument.`) } options = { ...args[1], paths: args[0] } } if(isString(args[0]) &amp;&amp; isObject(args[1])){ options = { rootPath: args[0], paths: args[1] } } } break case 3: { if(args[2].hasOwnProperty('rootPath')){ warn(`PathResolver was passed a 'rootPath' argument and an options object with the 'rootPath' property. Will use 'rootPath' argument.`) } if(args[2].hasOwnProperty('paths')){ warn(`PathResolver was passed a 'paths' argument and an options object with the 'paths' property. Will use 'paths' argument.`) } options = { ...args[2], rootPath: args[0], paths: args[1] } } break default: { throw new InvalidArgumentsError(`PathResolver accepts between 1-3 arguments, '${args.length}' found.`) } } return this._validateOptions(options) } _hasAlias = (object) =&gt; object.hasOwnProperty('_') &amp;&amp; object._.indexOf('@') == 0 _hasLocalAlias = (object) =&gt; object.hasOwnProperty('_') &amp;&amp; object._.indexOf('@') == -1 _setFileMap = (fileroot, rootPath, fullResolver) =&gt; { this[fileroot] = fullResolver this[fileroot]['_root'] = rootPath } _validateOptions = (options) =&gt; { let { namespace, fileroot, rootPath, resolverPrefix, ...other } = options let validated = Object.assign({}, PathResolver.defaultOptions, filterObject({ ...other, namespace: isString(namespace) &amp;&amp; namespace.trim().length &gt; 0 ? namespace : undefined, fileroot: isString(fileroot) &amp;&amp; fileroot.trim().length &gt; 0 ? fileroot : undefined, rootPath: isString(rootPath) &amp;&amp; rootPath.trim().length &gt; 0 ? rootPath : undefined, resolverPrefix: isString(rootPath) &amp;&amp; rootPath.trim().length &gt; 0 ? rootPath : undefined })) return validated } } export default PathResolver export { PathResolver } × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-02-18T14:46:53-05:00 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Documentation Classes PathResolver Classes Classes PathResolver × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-02-18T14:46:53-05:00 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Documentation Classes PathResolver × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-02-18T14:46:53-05:00 using the DocStrap template. "},"PathResolver.html":{"id":"PathResolver.html","title":"Class: PathResolver","body":" Documentation Classes PathResolver Class: PathResolver PathResolver Class that creates a suite of methods useful for resolving paths within a project. Includes a directory resolver, which creates relative path resolvers for each directory in a given directory map. Support for resolver renaming and alias generation, which formats the resolver name to reflect the alias as the root rather than the full path. new PathResolver(rootPath|paths, paths|options, options) Creates an instance of PathResolver. Passes arguments to PathResolver#initialize to be processed. Parameters: Name Type Argument Description rootPath|paths String | Object Projects root path or Object mapping projects directory structure paths|options Object &lt;nullable&gt; Object mapping projects directory structure or options object options Object &lt;nullable&gt; Options object Source: PathResolver.js, line 67 Methods initialize(rootPath|paths, paths|options, options) Configures an instance of path resolver. Can be used after a PathResolver instance is created to defer the configuration. Passes arguments to the PathResolver#initialize function to be processed and validated and sets the options instance property. Then passes on the configured rootPath, paths object, and designated fileroot Parameters: Name Type Argument Description rootPath|paths String | Object Projects root path or Object mapping projects directory structure paths|options Object &lt;nullable&gt; Object mapping projects directory structure or options object options Object &lt;nullable&gt; Options object Source: PathResolver.js, line 105 makeRelativeResolver(rootPath) Creates a resolver function, relative to the given path. Parameters: Name Type Description rootPath String The absolute path which the resolver will be relative to. Source: PathResolver.js, line 128 Returns: Returns a function that returns a path relative to rootPath Type function Example let resolver = makeRelativeResolver('absolute/path') let path = resolver('index.html') console.log(path) // absolute/path/index.html &lt;private&gt; _addPathToResolver(rootPath) Creates a resolver function, relative to the given path. Parameters: Name Type Description rootPath String The absolute path which the resolver will be relative to. Source: PathResolver.js, line 145 Example let resolver = makeRelativeResolver('absolute/path') let path = resolver('index.html') console.log(path) // absolute/path/index.html &lt;private&gt; _getDirectoryResolverKey(key, scope) Creates a directory resolver key, or a dynamic function name, to be applied to the directory resolver. Parameters: Name Type Argument Description key String &lt;nullable&gt; Key for current directory or file scope String &lt;nullable&gt; A string representation of the nested path in kebab case 'this-is-kebab-case' Source: PathResolver.js, line 259 Returns: Name for dynamically generated resolver function. Type String &lt;private&gt; _getLocalScope(key, scope) Gets the current scope. Checks if current item has an alias scope, otherwise returns scope. Parameters: Name Type Description key String Key for current directory or file scope String A string representation of the nested path in kebab case 'this-is-kebab-case' Source: PathResolver.js, line 301 Throws: _getLocalScope was passed no valid parameters, would have returned undefined Type TypeError Returns: Name for dynamically generated resolver function. Type String × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-02-18T14:46:53-05:00 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
